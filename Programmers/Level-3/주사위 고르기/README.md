# 주사위 고르기

# 24.03.17

여러가지 알고리즘을 적절히 사용해야 풀 수 있는 문제, 기본적으로 완전 탐색에 가까운 문제이다.

처음 주사위를 고르는 경우의 수를 구하기 위해 **조합(combination)** 을 만들어야 한다.

이후 고른 주사위들이 가질 수 있는 숫자의 합을 **누적합(prefix sum)** 을 이용하여 구하였다.

마지막으로 주사위 A, B에 대해 만들어진 누적합을 이용하여 A가 이기는 경우의 수를 구하기 위해 **이분 탐색(Binary Serach)** 를 이용하였다.

각 단계에 적합한 풀이를 선택하기 위해 시간복잡도가 낮은 적절한 알고리즘을 선택하는 과정을 연습할 수 있었다.

# 카카오 해설

이 문제는 제한사항을 파악해, 효율적인 시간복잡도의 완전탐색 풀이를 설계할 수 있어야 합니다.

주사위 눈의 합이 큰 순서대로 주사위를 가져가면 최적이라는 착각을 할 수 있으나, 단순히 눈의 합이 큰 주사위를 가져간다고 해서 승률이 높아지지는 않습니다. 테스트케이스 제한사항의 크기가 작으므로, 가능한 모든 경우를 탐색하는 방법으로 문제를 해결할 수 있습니다. 단, 제한사항을 고려해 지나치게 비효율적인 시간복잡도가 되지 않도록 주의해야 합니다.

풀이를 크게 1: A가 가져갈 주사위를 선택하는 부분과, 2: 가져간 주사위를 굴린 결과를 세는 부분으로 나누겠습니다.

풀이 1: A가 가져갈 주사위를 선택하는 부분
A가 가져갈 주사위를 선택하는 모든 경우를 완전탐색으로 찾습니다. 백트래킹, 비트마스킹 등의 기법을 사용해 주사위를 선택하거나, 언어에 따라 조합(Combination)을 구할 수 있는 라이브러리를 적절히 사용하면 해당 구현이 가능합니다. 이러한 방법으로 탐색하게 되는 경우의 수는 n개의 주사위 중 n/2개의 주사위를 고르는 방법의 수입니다. 문제의 제한에 따르면 n의 최댓값은 10이고, n이 최댓값일 때 10개의 주사위 중 5개의 주사위를 고르는 방법의 수는 252입니다.

풀이 2: 가져간 주사위를 굴린 결과를 세는 부분
2-1) 시간복잡도를 고려하지 않은 완전탐색

다음으로 A, B가 가져간 주사위 조합마다 A의 승률을 계산하기 위해, 각 주사위를 굴린 모든 경우를 시뮬레이션해 A가 이기는 경우의 수를 구합니다. 이때, A, B의 주사위를 한꺼번에 모두 시뮬레이션한다면 각 주사위마다 나올 수 있는 눈이 6개이므로 6^n가지 경우를 탐색하게 됩니다. 이러한 방법으로 가능한 주사위 조합마다 모든 6^n가지 경우를 시뮬레이션하게 되면, n이 최댓값인 10일 때 252 × 6^10 = 15,237,476,352가지 경우를 탐색하게 되므로, 시간초과를 받게 됩니다.

2-2) 시간복잡도를 고려한 완전탐색

시간복잡도를 줄이기 위해 A와 B의 주사위를 한꺼번에 모두 시뮬레이션해 승패를 판단하는 대신, A와 B의 주사위를 따로 시뮬레이션하는 아이디어가 필요합니다.

먼저 A의 주사위를 굴린 결과만 시뮬레이션해 6^(n/2) 가지에 대해 주사위 눈의 합을 저장해 두고, 마찬가지로 B의 주사위를 굴린 결과 6^(n/2) 가지에 대해 주사위 눈의 합을 저장해 둡니다. A와 B의 주사위 눈의 합을 저장해 둔 배열을 각각 arrA, arrB라고 하겠습니다. arrA의 각 원소 x에 대해, x보다 작은 arrB의 원소 개수를 세어, 그 값을 모두 합하면 A가 승리하는 경우의 수와 같아집니다. 이 값은 배열 arrA, arrB를 정렬한 뒤 누적 합, 투 포인터, 이분 탐색등의 기법을 사용해 구할 수 있습니다. arrA의 길이 6^(n/2)를 m이라고 할 때, 정렬이 필요 없는 구현의 경우 O(m), 정렬이 필요한 구현의 경우 O(m × log m)의 시간복잡도를 가집니다. n이 최댓값인 10일 때 m은 6^5 = 7,776이므로, 가능한 주사위 조합의 최댓값인 252를 곱해도 충분히 빠른 실행시간을 가지게 됩니다.

위에서 설명한 풀이 1과 2의 두 구현 부분을 합치면, 가능한 모든 주사위 조합에 대해 A가 승리하는 경우의 수를 구할 수 있고, 그중 승률이 가장 높은 주사위 조합을 찾을 수 있습니다.
