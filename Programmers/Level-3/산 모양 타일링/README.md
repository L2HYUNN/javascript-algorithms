# 산 모양 타일링

# 24.03.14

마름모가 위에 삼각형 아래 삼각형으로 이루어져있다는 것을 알 수 있었고 점화식을 만들어보려 노력했지만 실패했다. 이후 해설을 참고하여 삼각형의 특징을 찾아내는 기준을 알아내었고 이후 기준을 바탕으로 점화식을 세워보았다. 아래는 코드를 짜기 전 생각한 내용이다.

# 풀이 전 생각 정리

point
문제에서 구조가 반복되고 있다.

첫 접근 탐색인가? -> 탐색이 어렵다면 도형의 특징을 찾아본다.

모든 마름모는 아래 삼각형, 위 삼각형으로 구성되어 있다.

사다리꼴은 항상 아래방향 삼각형을 하나 포함하며 이것을 덮는 방법을 기준으로 생각해보자.

윗변의 길이가 n이기 때문에 이 n을 기준으로 생각한다.

아래 삼각형을 덮는방법?

1. 위에 삼각형과 함께
2. 왼쪽 삼각형과 함께
3. 오른쪽 삼각형과 함께
4. 삼각형 혼자

나눌 수 있는 두 가지 경우의 수

1. 위 뿔이 존재하는 경우
2. 위 뿔이 존재하지 않는 경우

k와 k-1의 경우를 살펴보자.

k-1을 3번을 적용해 덮는 경우 k번째는 2번을 이용할 수 없다.

k번째에 3번을 적용하는 경우 a[k]
k번째에 3번을 적용하지 않는 경우 b[k] 1, 2, 4

- Case 01. 위 뿔이 존재하는 경우

a[k] = a[k-1] + b[k-1] -> 이전 경우는 어떤 경우든 상관없다.

b[k] = 2 x a[k-1] + 3 x b[k-1]
-> 이전 경우가 3번이 아니기 때문에 a[k-1]의 경우 b[k]는 1, 4 두 가지 b[k-1]의 경우 1, 2, 4 총 3가지가 있을 수 있다.

- Case 02. 위 뿔이 존재하지 않는 경우 1번 제외

a[k] = a[k-1] + b[k-1]

b[k] = a[k-1] + 2 x b[k-1]

각 경우의 a[n] b[n]을 구하자.

# 키워드 정리

- 반복
- 점화식
- 다이나믹 프로그래밍

# 카카오 해설

이 문제는 정삼각형 격자 타일링의 특징을 이용해, 타일링 방법을 단순화해야 문제를 해결할 수 있습니다.

정삼각형 격자에서 마름모 타일은 언제나 사다리꼴의 윗변과 변을 공유하는 아래 방향 정삼각형(▽ 모양) 하나와 위 방향 정삼각형(△ 모양) 하나를 덮게 됩니다. 이 문제에서 아래 방향 정삼각형의 개수는 사다리꼴의 윗변의 길이인 n이기 때문에, 먼저 아래 방향 정삼각형 n개를 어떻게 덮을지 결정하고 남은 부분을 모두 정삼각형 타일로 덮는 경우의 수를 세는 방법으로 답을 구할 수 있습니다.

아래 방향 정삼각형을 타일로 덮는 방법은 아래와 같이 총 4가지입니다.

위쪽 정삼각형과 함께 마름모 타일로 덮기
왼쪽 정삼각형과 함께 마름모 타일로 덮기
오른쪽 정삼각형과 함께 마름모 타일로 덮기
정삼각형 타일로 덮기

가장 왼쪽의 아래 방향 정삼각형부터 시작하여 오른쪽으로 가며 하나씩 타일로 덮는 방법을 결정해 나갑니다. 이때, 아래와 같은 조건을 고려해야 합니다.

1번 방법은 위쪽 정삼각형이 있는 경우에만 적용할 수 있습니다.
직전 아래 방향 정삼각형에 3번 방법을 적용했다면, 현재 아래 방향 정삼각형에 2번 방법을 적용할 수 없습니다.

가장 최근 아래 방향 정삼각형에 적용한 방법이 3번 방법인지의 여부가 다음 아래 방향 정삼각형을 덮는 방법에 영향을 미칩니다. 따라서 아래와 같이 두 개의 배열을 정의해야 합니다.
a[k] = k번째 아래 방향 정삼각형까지 덮되, k번째 아래 방향 정삼각형을 덮는 방법이 3번 방법인 경우의 수
b[k] = k번째 아래 방향 정삼각형까지 덮되, k번째 아래 방향 정삼각형을 덮는 방법이 3번 방법이 아닌 경우의 수
이제, a[k]와 b[k]를 a[k-1]과 b[k-1]에 대한 점화식으로 표현해 봅시다.
Case 1. `k`번째 아래 방향 정삼각형 위에 정삼각형이 붙은 경우 (tops[k-1] = 1)
a[k]의 경우, k-1번째 아래 방향 정삼각형을 덮은 방법이 3번 방법인지와 관계없이 3번 방법을 적용할 수 있습니다. 따라서, a[k] = a[k-1] + b[k-1]입니다.

b[k]의 경우, 만약 k-1번째 아래 방향 정삼각형을 덮은 방법이 3번 방법이었다면, k번째 아래 방향 정삼각형에는 1번 또는 4번 방법을 적용할 수 있습니다. 그렇지 않다면 1번, 2번, 4번 중 하나의 방법을 적용할 수 있습니다. 따라서, k-1번째 아래 방향 정삼각형을 3번 방법으로 덮는 a[k-1]개의 방법 각각마다 2개씩, 그리고 k-1번째 아래 방향 정삼각형을 3번 방법이 아닌 방법으로 덮는 b[k-1]개의 방법 각각마다 3개씩의 방법이 있습니다. 따라서 b[k] = 2 × a[k-1] + 3 × b[k-1]입니다.

Case 2. `k`번째 아래 방향 정삼각형 위에 정삼각형이 붙지 않은 경우 (tops[k-1] = 0)
a[k]의 경우 Case 1과 동일하게 a[k] = a[k-1] + b[k-1]입니다.

b[k]의 경우, 1번 방법을 적용할 수 없습니다. 따라서, k-1번째 아래 방향 정삼각형을 3번 방법으로 덮는 a[k-1]개의 방법 각각마다 1개씩, 그리고 k-1번째 아래 방향 정삼각형을 3번 방법이 아닌 방법으로 덮는 b[k-1]개의 방법 각각마다 2개씩의 방법이 있습니다. 따라서, b[k] = a[k-1] + 2 x b[k-1]입니다.

이와 같이 a[k]와 b[k]를 a[k-1]과 b[k-1]에 대한 식으로 나타낼 수 있으므로, 다이나믹 프로그래밍을 이용하여 a[n]과 b[n]을 구할 수 있습니다. 초기값은 a[1]=1, b[1]은 1번째 정삼각형 위에 정삼각형이 붙은 경우 3, 그렇지 않은 경우 2로 초기화하거나, a[0] = 0, b[0] = 1로 초기화하는 방법이 있습니다.

구하려는 정답은 a[n] + b[n]입니다. 경우의 수를 10007로 나눈 나머지를 구해야 하므로, 연산을 할 때마다 10007로 나눈 나머지를 구하여 저장하면 됩니다. 예를 들어, a[k] = (a[k-1] + b[k-1]) % 10007와 같이 계산하면 됩니다.이때, 전체 시간복잡도는 O(n)입니다.
