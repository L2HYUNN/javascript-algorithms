/**
 * # Graph
 * 그래프(Graph)는 객체 사이의 연결 관계를 표현할 수 있는 자료 구조이다.
 * 정점(vertex)과 간선(edge)을 이용하여 표현할 수 있다.
 */

/**
 * ## 그래프의 용어
 * 그래프는 정점(vertex)과 간선(edge)들의 유한집합이라 할 수 있다.
 * 수학적으로는 G = (V, E)와 같이 표시한다.
 *
 * 정점(vertex)은 여러 가지 특성을 가질 수 있는 객체를 의미한다.
 * 간선(edge)은 이러한 정점 간의 관계를 의미한다.
 *
 * 정점(vertex)은 노드(node)라고도 하며, 간선(edge)은 링크(link)라고도 한다.
 *
 * 정점의 차수
 * 무방향 그래프에서 하나의 정점에 인접한 정점의 수
 *
 * 진입 차수
 * 방향 그래프에서 외부에서 오는 간선의 수
 *
 * 진출 차수
 * 방향 그래프에서 외부로 향하는 간서의 수
 *
 * 경로길이
 * 경로를 구성하기 위해 사용된 간선의
 */

/**
 * ## 그래프의 종류
 *
 * ### 무방향 그래프와 방향 그래프
 * 간선의 종류에 따라 무방향 그래프(undirected graph)와 방향 그래프(directed graph)로 나눌 수 있다.
 *
 * - 무방향 그래프(undirected graph)
 * 간선에 방향이 없는 그래프로 간선을 통해 양방향으로 이동할 수 있다.
 * 정점 A와 정점 B를 잇는 간선을 (A, B)와 같이 표현할 수 있다.
 *
 * 무방향 그래프에서 (A, B)와 (B, A)는 같은 간선이 된다.
 *
 * - 방향 그래프(directed graph)
 * 간선에 방향이 있는 그래프로 간선을 통해서 한쪽으로만 갈 수 있다.
 * 정점 A와 정점 B를 잇는 간선을 <A, B>와 같이 표현할 수 있다.
 *
 * 방향 그래프에서 <A, B>와  <B,A>는 서로 다른 간선이다.
 *
 * ### 가중 그래프 또는 가중 네트워크
 *
 * - 가중 그래프(weighted graph), 가중 네트워크(weighted network)
 * 간선에 가중치가 할당되어 연결 강도까지 나타낸 그래프로 보다 복잡한 관계를 표현할 수 있다.
 *
 * ### 연결 그래프와 비연결 그래프
 *
 * - 연결 그래프(connected graph)
 * 무방향 그래프에 있는 모든 정점에 대해 항상 경로가 존재하는 그래프
 * 모든 그래프는 연결되어 있다.
 *
 * - 비연결 그래프(disconnected graph)
 * 특정 정점에 대한 경로가 없는 그래프
 * 일부 연결되지 않은 별개의 그래프가 존재한다.
 *
 * ### 완전 그래프
 *
 * - 완전 그래프(complete graph)
 * 그래프에 속해 있는 모든 정점이 서로 연결된 그래프
 * 무방향 완전 그래프의 정점 수를 n이라고 할 때, 간선의 수는 n * (n - 1) / 2이다.
 *
 * ### 부분 그래프
 *
 * - 부분 그래프(sub graph)
 * 다른 그래프의 정점 일부와 간선 일부로 이루어진 그래프
 */

/**
 * ## 그래프의 표현 방법
 * 그래프는 다음과 같이 크게 2가지 방식으로 표현할 수 있다.
 *
 * 1. 인접 행렬(adjacency matrix)
 * 2. 인접 리스트(adjacency list)
 */

/**
 * ### 인접 행렬(adjacency matrix)로 표현한 그래프
 * 2차원 배열을 이용하여 각 노드의 연결 관계를 표현한다.
 * 연결이 되어 있지 않은 노드끼리는 무한(Infinity)의 비용이라고 작성한다.
 *
 * 노드에 대한 가중치가 있는 경우 가중치를 입력해주고,
 * 가중치가 없는 경우 1과 0을 이용하여 연결 관계를 표현한다.
 *
 * 인접 행렬 방식을 사용하면 노드의 연결 관계를 담은 배열이 중앙 대각선을 기준으로 대칭을 이루게 된다.
 */

// 가중치가 없는 인접 행렬 그래프
const matrixGraph = [
  [0, 1, 0, 1, 1, 0],
  [1, 0, 1, 0, 0, 0],
  [0, 1, 0, 1, 0, 0],
  [1, 0, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 1],
  [0, 0, 0, 0, 1, 0],
];

// 가중치가 있는 인접 행렬 그래프
const INF = Number.MAX_SAFE_INTEGER;

const weightedMatrixGraph = [
  [0, 9, INF, 2, 7, INF],
  [9, 0, 20, INF, INF, INF],
  [INF, 20, 0, 16, INF, INF],
  [2, INF, 16, 0, INF, INF],
  [7, INF, INF, INF, 0, 10],
  [INF, INF, INF, INF, 10, 0],
];

/**
 * ### 인접 리스트(adjacency list)로 표현한 그래프
 * 리스트를 이용하여 그래프의 연결 관계를 표현한다.
 * 각 노드에 연결 정보를 차례대로 연결하여 저장한다
 *
 * 노드에 대한 가중치가 있는 경우 가중치를 함꼐 입력해준다.
 * 가중치가 없는 경우 2차원 배열을 이용하여 연결 관계를 표현한다.
 */

// 가중치가 없는 인접 리스트 그래프
const listGraph = [[1, 3, 4], [0, 2], [1, 3], [0, 2], [0, 5], [4]];

// 가중치가 있는 인접 리스트 그래프
const weightedListGraph = [
  [
    [1, 9],
    [3, 2],
    [4, 7],
  ],
  [
    [0, 9],
    [2, 20],
  ],
  [
    [1, 20],
    [3, 16],
  ],
  [
    [0, 2],
    [2, 16],
  ],
  [
    [0, 7],
    [5, 10],
  ],
  [[4, 10]],
];

/**
 * ### 인접 행렬 방식과 인접 리스트 방식의 차이점
 * 메모리 측면에서 보았을 때,
 * 인접 행렬 방식은 노드의 모든 관계를 저장하기 때문에 많은 메모리를 사용하게 된다.
 *
 * 반면,
 * 인접 리스트 방식은 연결된 정보만을 저장하기 때문에 상대적으로 메모리를 적게 사용할 수 있다
 *
 * 하지만 인접 리스트 방식은 연결된 데이터를 하나씩 확인해야 하므로
 * 인접 행렬 방식에 비해 특정한 두 노드의 연결에 대한 정보를 얻는 속도가 느리다.
 */

/**
 * ## 그래프의 탐색
 * 그래프의 탐색이란 하나의 노드로부터 시작하여 차례대로 모든 노드를 한 번씩 탐색(방문)하는 것을 말한다.
 * 많은 문제를 그래프의 노드 탐색을 통해 해결할 수 있다.
 *
 * 각 노드를 탐색하는 방법에는 크게 2가지 알고리즘을 이용할 수 있다.
 *
 * 1. DFS, 깊이 우선 탐색(Depth First Search)
 * 2. BFS, 너비 우선 탐색(Breath First Search)
 *
 * 깊이 우선 탐색(DFS)는 주로 스택으로 구현하거나 재귀로 구현한다.
 * 너비 우선 탐색(BFS)는 주로 큐로 구현하며 그래프의 최단 경로를 구하는 문제 등에 사용된다.
 */

// 참고 https://chamdom.blog/graph/
